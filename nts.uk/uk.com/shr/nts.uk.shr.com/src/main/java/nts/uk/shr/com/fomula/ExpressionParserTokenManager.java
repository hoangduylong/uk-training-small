/* Generated By:JavaCC: Do not edit this line. ExpressionParserTokenManager.java */
package nts.uk.shr.com.fomula;

/*import java.math.RoundingMode;
import java.math.MathContext;
import java.math.BigDecimal;
import java.util.Stack;
import java.io.StringReader;*/

/** Token Manager. */
public class ExpressionParserTokenManager implements ExpressionParserConstants {

	/** Debug output. */
	public java.io.PrintStream debugStream = System.out;

	/** Set debug output. */
	public void setDebugStream(java.io.PrintStream ds) {
		debugStream = ds;
	}

	private final int jjStopStringLiteralDfa_0(int pos, long active0) {
		switch (pos) {
		case 0:
			if ((active0 & 0x4L) != 0L)
				return 1;
			return -1;
		default:
			return -1;
		}
	}

	private final int jjStartNfa_0(int pos, long active0) {
		return jjMoveNfa_0(jjStopStringLiteralDfa_0(pos, active0), pos + 1);
	}

	private int jjStopAtPos(int pos, int kind) {
		jjmatchedKind = kind;
		jjmatchedPos = pos;
		return pos + 1;
	}

	private int jjMoveStringLiteralDfa0_0() {
		switch (curChar) {
		case 10:
			return jjStopAtPos(0, 5);
		case 31445:
			return jjMoveStringLiteralDfa1_0(0x8c00000L);
		case 32306:
			return jjMoveStringLiteralDfa1_0(0x4L);
		default:
			return jjMoveNfa_0(0, 0);
		}
	}

	private int jjMoveStringLiteralDfa1_0(long active0) {
		try {
			curChar = input_stream.readChar();
		} catch (java.io.IOException e) {
			jjStopStringLiteralDfa_0(0, active0);
			return 1;
		}
		switch (curChar) {
		case 65382:
			if ((active0 & 0x800000L) != 0L)
				return jjStopAtPos(1, 23);
			break;
		case 65383:
			if ((active0 & 0x400000L) != 0L)
				return jjStopAtPos(1, 22);
			break;
		case 65533:
			if ((active0 & 0x4L) != 0L)
				return jjStopAtPos(1, 2);
			else if ((active0 & 0x8000000L) != 0L)
				return jjStopAtPos(1, 27);
			break;
		default:
			break;
		}
		return jjStartNfa_0(0, active0);
	}

	static final long[] jjbitVec0 = { 0x0L, 0x0L, 0x0L, 0x2000000000000000L };
	static final long[] jjbitVec1 = { 0x4000000000000L, 0x0L, 0x0L, 0x0L };
	static final long[] jjbitVec2 = { 0x0L, 0x2000000000L, 0x0L, 0x0L };
	static final long[] jjbitVec3 = { 0x0L, 0x0L, 0x0L, 0x1000L };
	static final long[] jjbitVec4 = { 0x0L, 0x0L, 0x100000000L, 0x0L };
	static final long[] jjbitVec5 = { 0x8000L, 0x0L, 0x0L, 0x0L };
	static final long[] jjbitVec6 = { 0x40000000000000L, 0x0L, 0x0L, 0x0L };
	static final long[] jjbitVec7 = { 0x0L, 0x800000L, 0x0L, 0x0L };
	static final long[] jjbitVec8 = { 0x20000L, 0x0L, 0x0L, 0x0L };
	static final long[] jjbitVec9 = { 0x0L, 0x40000000000000L, 0x0L, 0x0L };
	static final long[] jjbitVec10 = { 0x0L, 0x0L, 0x200L, 0x0L };
	static final long[] jjbitVec11 = { 0x0L, 0x200000000L, 0x0L, 0x0L };
	static final long[] jjbitVec12 = { 0x0L, 0x4000000L, 0x0L, 0x0L };
	static final long[] jjbitVec13 = { 0x0L, 0x1000000000000000L, 0x0L, 0x0L };
	static final long[] jjbitVec14 = { 0x0L, 0x4000000000000000L, 0x0L, 0x0L };
	static final long[] jjbitVec15 = { 0x0L, 0x0L, 0x8L, 0x0L };
	static final long[] jjbitVec16 = { 0x0L, 0x80000000000000L, 0x0L, 0x0L };
	static final long[] jjbitVec17 = { 0x0L, 0x0L, 0x0L, 0x800000000000000L };
	static final long[] jjbitVec18 = { 0x0L, 0x4000000000L, 0x0L, 0x0L };
	static final long[] jjbitVec19 = { 0x400000000000000L, 0x0L, 0x0L, 0x0L };
	static final long[] jjbitVec20 = { 0x0L, 0x8000000000L, 0x0L, 0x0L };
	static final long[] jjbitVec21 = { 0x0L, 0x0L, 0x0L, 0x200000000L };
	static final long[] jjbitVec22 = { 0x0L, 0x0L, 0x0L, 0x80000000000L };
	static final long[] jjbitVec23 = { 0x0L, 0x100000000000000L, 0x0L, 0x0L };
	static final long[] jjbitVec24 = { 0x800L, 0x0L, 0x0L, 0x0L };
	static final long[] jjbitVec25 = { 0x0L, 0x8000000L, 0x0L, 0x0L };
	static final long[] jjbitVec26 = { 0x0L, 0x1000000000L, 0x0L, 0x0L };
	static final long[] jjbitVec27 = { 0x0L, 0x0L, 0x0L, 0x80000000L };
	static final long[] jjbitVec28 = { 0x0L, 0x0L, 0x80000000L, 0x0L };
	static final long[] jjbitVec29 = { 0x40000000L, 0x0L, 0x0L, 0x0L };
	static final long[] jjbitVec30 = { 0x0L, 0x0L, 0x0L, 0x40L };
	static final long[] jjbitVec31 = { 0x0L, 0x0L, 0x2000000000000000L, 0x0L };
	static final long[] jjbitVec32 = { 0x0L, 0x20000000L, 0x0L, 0x0L };
	static final long[] jjbitVec33 = { 0x0L, 0x800000000000L, 0x0L, 0x0L };
	static final long[] jjbitVec34 = { 0x0L, 0x0L, 0x1000000L, 0x0L };

	private int jjMoveNfa_0(int startState, int curPos) {
		int startsAt = 0;
		jjnewStateCnt = 144;
		int i = 1;
		jjstateSet[0] = startState;
		int kind = 0x7fffffff;
		for (;;) {
			if (++jjround == 0x7fffffff)
				ReInitRounds();
			if (curChar < 64) {
				long l = 1L << curChar;
				do {
					switch (jjstateSet[--i]) {
					case 0:
						if ((0x3ff000000000000L & l) != 0L) {
							if (kind > 28)
								kind = 28;
							jjCheckNAddTwoStates(47, 48);
						} else if (curChar == 61) {
							if (kind > 26)
								kind = 26;
						} else if (curChar == 60) {
							if (kind > 25)
								kind = 25;
						} else if (curChar == 62) {
							if (kind > 24)
								kind = 24;
						} else if (curChar == 47) {
							if (kind > 12)
								kind = 12;
						} else if (curChar == 42) {
							if (kind > 11)
								kind = 11;
						} else if (curChar == 45) {
							if (kind > 10)
								kind = 10;
						} else if (curChar == 43) {
							if (kind > 9)
								kind = 9;
						} else if (curChar == 41) {
							if (kind > 8)
								kind = 8;
						} else if (curChar == 40) {
							if (kind > 7)
								kind = 7;
						} else if (curChar == 44) {
							if (kind > 6)
								kind = 6;
						}
						break;
					case 3:
						if (curChar == 40)
							kind = 7;
						break;
					case 4:
						if (curChar == 41)
							kind = 8;
						break;
					case 5:
						if (curChar == 43)
							kind = 9;
						break;
					case 6:
						if (curChar == 45)
							kind = 10;
						break;
					case 7:
						if (curChar == 42)
							kind = 11;
						break;
					case 8:
						if (curChar == 47)
							kind = 12;
						break;
					case 44:
						if (curChar == 62)
							kind = 24;
						break;
					case 45:
						if (curChar == 60)
							kind = 25;
						break;
					case 46:
						if (curChar == 61)
							kind = 26;
						break;
					case 47:
						if ((0x3ff000000000000L & l) == 0L)
							break;
						if (kind > 28)
							kind = 28;
						jjCheckNAddTwoStates(47, 48);
						break;
					case 48:
						if (curChar == 46)
							jjCheckNAdd(49);
						break;
					case 49:
						if ((0x3ff000000000000L & l) == 0L)
							break;
						if (kind > 28)
							kind = 28;
						jjCheckNAdd(49);
						break;
					default:
						break;
					}
				} while (i != startsAt);
			} else if (curChar < 128) {
				/*long l = 1L << (curChar & 077);*/
				do {
					switch (jjstateSet[--i]) {
					case 0:
						if (curChar == 77)
							jjAddStates(0, 3);
						else if (curChar == 109)
							jjAddStates(4, 5);
						else if (curChar == 82)
							jjAddStates(6, 7);
						else if (curChar == 70)
							jjAddStates(8, 9);
						else if (curChar == 67)
							jjAddStates(10, 11);
						else if (curChar == 73)
							jjCheckNAddTwoStates(31, 57);
						else if (curChar == 65)
							jjAddStates(12, 13);
						else if (curChar == 79)
							jjCheckNAddTwoStates(42, 51);
						else if (curChar == 111)
							jjCheckNAdd(42);
						else if (curChar == 97)
							jjstateSet[jjnewStateCnt++] = 40;
						else if (curChar == 105)
							jjCheckNAdd(31);
						else if (curChar == 99)
							jjstateSet[jjnewStateCnt++] = 29;
						else if (curChar == 102)
							jjstateSet[jjnewStateCnt++] = 25;
						else if (curChar == 114)
							jjstateSet[jjnewStateCnt++] = 13;
						else if (curChar == 94) {
							if (kind > 13)
								kind = 13;
						}
						break;
					case 9:
						if (curChar == 94)
							kind = 13;
						break;
					case 10:
						if (curChar == 100 && kind > 14)
							kind = 14;
						break;
					case 11:
					case 73:
						if (curChar == 110)
							jjCheckNAdd(10);
						break;
					case 12:
						if (curChar == 117)
							jjstateSet[jjnewStateCnt++] = 11;
						break;
					case 13:
						if (curChar == 111)
							jjstateSet[jjnewStateCnt++] = 12;
						break;
					case 14:
						if (curChar == 114)
							jjstateSet[jjnewStateCnt++] = 13;
						break;
					case 22:
						if (curChar == 114 && kind > 15)
							kind = 15;
						break;
					case 23:
					case 65:
						if (curChar == 111)
							jjCheckNAdd(22);
						break;
					case 24:
						if (curChar == 111)
							jjstateSet[jjnewStateCnt++] = 23;
						break;
					case 25:
						if (curChar == 108)
							jjstateSet[jjnewStateCnt++] = 24;
						break;
					case 26:
						if (curChar == 102)
							jjstateSet[jjnewStateCnt++] = 25;
						break;
					case 27:
						if (curChar == 108 && kind > 16)
							kind = 16;
						break;
					case 28:
					case 59:
						if (curChar == 105)
							jjCheckNAdd(27);
						break;
					case 29:
						if (curChar == 101)
							jjstateSet[jjnewStateCnt++] = 28;
						break;
					case 30:
						if (curChar == 99)
							jjstateSet[jjnewStateCnt++] = 29;
						break;
					case 31:
						if (curChar == 102 && kind > 19)
							kind = 19;
						break;
					case 32:
						if (curChar == 105)
							jjCheckNAdd(31);
						break;
					case 39:
						if (curChar == 100 && kind > 20)
							kind = 20;
						break;
					case 40:
					case 53:
						if (curChar == 110)
							jjCheckNAdd(39);
						break;
					case 41:
						if (curChar == 97)
							jjstateSet[jjnewStateCnt++] = 40;
						break;
					case 42:
						if (curChar == 114 && kind > 21)
							kind = 21;
						break;
					case 43:
						if (curChar == 111)
							jjCheckNAdd(42);
						break;
					case 50:
						if (curChar == 79)
							jjCheckNAddTwoStates(42, 51);
						break;
					case 51:
						if (curChar == 82 && kind > 21)
							kind = 21;
						break;
					case 52:
						if (curChar == 65)
							jjAddStates(12, 13);
						break;
					case 54:
						if (curChar == 68 && kind > 20)
							kind = 20;
						break;
					case 55:
						if (curChar == 78)
							jjstateSet[jjnewStateCnt++] = 54;
						break;
					case 56:
						if (curChar == 73)
							jjCheckNAddTwoStates(31, 57);
						break;
					case 57:
						if (curChar == 70 && kind > 19)
							kind = 19;
						break;
					case 58:
						if (curChar == 67)
							jjAddStates(10, 11);
						break;
					case 60:
						if (curChar == 101)
							jjstateSet[jjnewStateCnt++] = 59;
						break;
					case 61:
						if (curChar == 76 && kind > 16)
							kind = 16;
						break;
					case 62:
						if (curChar == 73)
							jjstateSet[jjnewStateCnt++] = 61;
						break;
					case 63:
						if (curChar == 69)
							jjstateSet[jjnewStateCnt++] = 62;
						break;
					case 64:
						if (curChar == 70)
							jjAddStates(8, 9);
						break;
					case 66:
						if (curChar == 111)
							jjstateSet[jjnewStateCnt++] = 65;
						break;
					case 67:
						if (curChar == 108)
							jjstateSet[jjnewStateCnt++] = 66;
						break;
					case 68:
						if (curChar == 82 && kind > 15)
							kind = 15;
						break;
					case 69:
						if (curChar == 79)
							jjstateSet[jjnewStateCnt++] = 68;
						break;
					case 70:
						if (curChar == 79)
							jjstateSet[jjnewStateCnt++] = 69;
						break;
					case 71:
						if (curChar == 76)
							jjstateSet[jjnewStateCnt++] = 70;
						break;
					case 72:
						if (curChar == 82)
							jjAddStates(6, 7);
						break;
					case 74:
						if (curChar == 117)
							jjstateSet[jjnewStateCnt++] = 73;
						break;
					case 75:
						if (curChar == 111)
							jjstateSet[jjnewStateCnt++] = 74;
						break;
					case 76:
						if (curChar == 68 && kind > 14)
							kind = 14;
						break;
					case 77:
						if (curChar == 78)
							jjstateSet[jjnewStateCnt++] = 76;
						break;
					case 78:
						if (curChar == 85)
							jjstateSet[jjnewStateCnt++] = 77;
						break;
					case 79:
						if (curChar == 79)
							jjstateSet[jjnewStateCnt++] = 78;
						break;
					case 113:
						if (curChar == 109)
							jjAddStates(4, 5);
						break;
					case 114:
						if (curChar == 120)
							kind = 17;
						break;
					case 115:
					case 138:
						if (curChar == 97)
							jjCheckNAdd(114);
						break;
					case 116:
						if (curChar == 110 && kind > 18)
							kind = 18;
						break;
					case 117:
					case 141:
						if (curChar == 105)
							jjCheckNAdd(116);
						break;
					case 137:
						if (curChar == 77)
							jjAddStates(0, 3);
						break;
					case 139:
						if (curChar == 88)
							kind = 17;
						break;
					case 140:
						if (curChar == 65)
							jjstateSet[jjnewStateCnt++] = 139;
						break;
					case 142:
						if (curChar == 78 && kind > 18)
							kind = 18;
						break;
					case 143:
						if (curChar == 73)
							jjstateSet[jjnewStateCnt++] = 142;
						break;
					default:
						break;
					}
				} while (i != startsAt);
			} else {
				int hiByte = (int) (curChar >> 8);
				int i1 = hiByte >> 6;
				long l1 = 1L << (hiByte & 077);
				int i2 = (curChar & 0xff) >> 6;
				long l2 = 1L << (curChar & 077);
				do {
					switch (jjstateSet[--i]) {
					case 0:
						if (jjCanMove_1(hiByte, i1, i2, l1, l2))
							jjstateSet[jjnewStateCnt++] = 1;
						if (jjCanMove_7(hiByte, i1, i2, l1, l2))
							jjstateSet[jjnewStateCnt++] = 20;
						if (jjCanMove_12(hiByte, i1, i2, l1, l2))
							jjstateSet[jjnewStateCnt++] = 37;
						if (jjCanMove_0(hiByte, i1, i2, l1, l2))
							jjAddStates(14, 21);
						if (jjCanMove_15(hiByte, i1, i2, l1, l2))
							jjAddStates(22, 23);
						if (jjCanMove_17(hiByte, i1, i2, l1, l2))
							jjAddStates(24, 25);
						if (jjCanMove_26(hiByte, i1, i2, l1, l2))
							jjAddStates(26, 27);
						if (jjCanMove_19(hiByte, i1, i2, l1, l2))
							jjAddStates(28, 29);
						break;
					case 1:
						if (jjCanMove_0(hiByte, i1, i2, l1, l2) && kind > 6)
							kind = 6;
						break;
					case 2:
						if (jjCanMove_1(hiByte, i1, i2, l1, l2))
							jjstateSet[jjnewStateCnt++] = 1;
						break;
					case 15:
						if (jjCanMove_2(hiByte, i1, i2, l1, l2) && kind > 14)
							kind = 14;
						break;
					case 16:
						if (jjCanMove_0(hiByte, i1, i2, l1, l2))
							jjstateSet[jjnewStateCnt++] = 15;
						break;
					case 17:
						if (jjCanMove_3(hiByte, i1, i2, l1, l2))
							jjstateSet[jjnewStateCnt++] = 16;
						break;
					case 18:
						if (jjCanMove_4(hiByte, i1, i2, l1, l2))
							jjstateSet[jjnewStateCnt++] = 17;
						break;
					case 19:
						if (jjCanMove_5(hiByte, i1, i2, l1, l2))
							jjstateSet[jjnewStateCnt++] = 18;
						break;
					case 20:
						if (jjCanMove_6(hiByte, i1, i2, l1, l2))
							jjstateSet[jjnewStateCnt++] = 19;
						break;
					case 21:
						if (jjCanMove_7(hiByte, i1, i2, l1, l2))
							jjstateSet[jjnewStateCnt++] = 20;
						break;
					case 33:
						if (jjCanMove_0(hiByte, i1, i2, l1, l2) && kind > 19)
							kind = 19;
						break;
					case 34:
						if (jjCanMove_8(hiByte, i1, i2, l1, l2))
							jjstateSet[jjnewStateCnt++] = 33;
						break;
					case 35:
						if (jjCanMove_9(hiByte, i1, i2, l1, l2))
							jjstateSet[jjnewStateCnt++] = 34;
						break;
					case 36:
						if (jjCanMove_10(hiByte, i1, i2, l1, l2))
							jjstateSet[jjnewStateCnt++] = 35;
						break;
					case 37:
						if (jjCanMove_11(hiByte, i1, i2, l1, l2))
							jjstateSet[jjnewStateCnt++] = 36;
						break;
					case 38:
						if (jjCanMove_12(hiByte, i1, i2, l1, l2))
							jjstateSet[jjnewStateCnt++] = 37;
						break;
					case 80:
						if (jjCanMove_0(hiByte, i1, i2, l1, l2))
							jjAddStates(14, 21);
						break;
					case 81:
						if (jjCanMove_0(hiByte, i1, i2, l1, l2) && kind > 7)
							kind = 7;
						break;
					case 82:
						if (jjCanMove_13(hiByte, i1, i2, l1, l2))
							jjstateSet[jjnewStateCnt++] = 81;
						break;
					case 83:
						if (jjCanMove_0(hiByte, i1, i2, l1, l2) && kind > 8)
							kind = 8;
						break;
					case 84:
						if (jjCanMove_13(hiByte, i1, i2, l1, l2))
							jjstateSet[jjnewStateCnt++] = 83;
						break;
					case 85:
						if (jjCanMove_0(hiByte, i1, i2, l1, l2) && kind > 9)
							kind = 9;
						break;
					case 86:
						if (jjCanMove_13(hiByte, i1, i2, l1, l2))
							jjstateSet[jjnewStateCnt++] = 85;
						break;
					case 87:
						if (jjCanMove_0(hiByte, i1, i2, l1, l2) && kind > 10)
							kind = 10;
						break;
					case 88:
						if (jjCanMove_13(hiByte, i1, i2, l1, l2))
							jjstateSet[jjnewStateCnt++] = 87;
						break;
					case 89:
						if (jjCanMove_14(hiByte, i1, i2, l1, l2) && kind > 13)
							kind = 13;
						break;
					case 90:
						if (jjCanMove_13(hiByte, i1, i2, l1, l2))
							jjstateSet[jjnewStateCnt++] = 89;
						break;
					case 91:
						if (jjCanMove_0(hiByte, i1, i2, l1, l2) && kind > 24)
							kind = 24;
						break;
					case 92:
						if (jjCanMove_13(hiByte, i1, i2, l1, l2))
							jjstateSet[jjnewStateCnt++] = 91;
						break;
					case 93:
						if (jjCanMove_0(hiByte, i1, i2, l1, l2) && kind > 25)
							kind = 25;
						break;
					case 94:
						if (jjCanMove_13(hiByte, i1, i2, l1, l2))
							jjstateSet[jjnewStateCnt++] = 93;
						break;
					case 95:
						if (jjCanMove_0(hiByte, i1, i2, l1, l2) && kind > 26)
							kind = 26;
						break;
					case 96:
						if (jjCanMove_13(hiByte, i1, i2, l1, l2))
							jjstateSet[jjnewStateCnt++] = 95;
						break;
					case 97:
						if (jjCanMove_15(hiByte, i1, i2, l1, l2))
							jjAddStates(22, 23);
						break;
					case 98:
						if (jjCanMove_0(hiByte, i1, i2, l1, l2) && kind > 11)
							kind = 11;
						break;
					case 99:
						if (jjCanMove_16(hiByte, i1, i2, l1, l2) && kind > 12)
							kind = 12;
						break;
					case 100:
						if (jjCanMove_17(hiByte, i1, i2, l1, l2))
							jjAddStates(24, 25);
						break;
					case 101:
						if (jjCanMove_18(hiByte, i1, i2, l1, l2) && kind > 15)
							kind = 15;
						break;
					case 102:
						if (jjCanMove_19(hiByte, i1, i2, l1, l2))
							jjstateSet[jjnewStateCnt++] = 101;
						break;
					case 103:
						if (jjCanMove_5(hiByte, i1, i2, l1, l2))
							jjstateSet[jjnewStateCnt++] = 102;
						break;
					case 104:
						if (jjCanMove_20(hiByte, i1, i2, l1, l2))
							jjstateSet[jjnewStateCnt++] = 103;
						break;
					case 105:
						if (jjCanMove_21(hiByte, i1, i2, l1, l2))
							jjstateSet[jjnewStateCnt++] = 104;
						break;
					case 106:
						if (jjCanMove_0(hiByte, i1, i2, l1, l2))
							jjstateSet[jjnewStateCnt++] = 105;
						break;
					case 107:
						if (jjCanMove_22(hiByte, i1, i2, l1, l2) && kind > 16)
							kind = 16;
						break;
					case 108:
						if (jjCanMove_23(hiByte, i1, i2, l1, l2))
							jjstateSet[jjnewStateCnt++] = 107;
						break;
					case 109:
						if (jjCanMove_24(hiByte, i1, i2, l1, l2))
							jjstateSet[jjnewStateCnt++] = 108;
						break;
					case 110:
						if (jjCanMove_25(hiByte, i1, i2, l1, l2))
							jjstateSet[jjnewStateCnt++] = 109;
						break;
					case 111:
						if (jjCanMove_21(hiByte, i1, i2, l1, l2))
							jjstateSet[jjnewStateCnt++] = 110;
						break;
					case 112:
						if (jjCanMove_0(hiByte, i1, i2, l1, l2))
							jjstateSet[jjnewStateCnt++] = 111;
						break;
					case 118:
						if (jjCanMove_26(hiByte, i1, i2, l1, l2))
							jjAddStates(26, 27);
						break;
					case 119:
						if (jjCanMove_27(hiByte, i1, i2, l1, l2) && kind > 17)
							kind = 17;
						break;
					case 120:
						if (jjCanMove_28(hiByte, i1, i2, l1, l2))
							jjstateSet[jjnewStateCnt++] = 119;
						break;
					case 121:
						if (jjCanMove_29(hiByte, i1, i2, l1, l2))
							jjstateSet[jjnewStateCnt++] = 120;
						break;
					case 122:
						if (jjCanMove_30(hiByte, i1, i2, l1, l2))
							jjstateSet[jjnewStateCnt++] = 121;
						break;
					case 123:
						if (jjCanMove_0(hiByte, i1, i2, l1, l2))
							jjstateSet[jjnewStateCnt++] = 122;
						break;
					case 124:
						if (jjCanMove_27(hiByte, i1, i2, l1, l2) && kind > 18)
							kind = 18;
						break;
					case 125:
						if (jjCanMove_0(hiByte, i1, i2, l1, l2))
							jjstateSet[jjnewStateCnt++] = 124;
						break;
					case 126:
						if (jjCanMove_31(hiByte, i1, i2, l1, l2))
							jjstateSet[jjnewStateCnt++] = 125;
						break;
					case 127:
						if (jjCanMove_32(hiByte, i1, i2, l1, l2))
							jjstateSet[jjnewStateCnt++] = 126;
						break;
					case 128:
						if (jjCanMove_0(hiByte, i1, i2, l1, l2))
							jjstateSet[jjnewStateCnt++] = 127;
						break;
					case 129:
						if (jjCanMove_19(hiByte, i1, i2, l1, l2))
							jjAddStates(28, 29);
						break;
					case 130:
						if (jjCanMove_33(hiByte, i1, i2, l1, l2) && kind > 20)
							kind = 20;
						break;
					case 131:
						if (jjCanMove_34(hiByte, i1, i2, l1, l2))
							jjstateSet[jjnewStateCnt++] = 130;
						break;
					case 132:
						if (jjCanMove_35(hiByte, i1, i2, l1, l2) && kind > 21)
							kind = 21;
						break;
					case 133:
						if (jjCanMove_0(hiByte, i1, i2, l1, l2))
							jjstateSet[jjnewStateCnt++] = 132;
						break;
					case 134:
						if (jjCanMove_36(hiByte, i1, i2, l1, l2))
							jjstateSet[jjnewStateCnt++] = 133;
						break;
					case 135:
						if (jjCanMove_19(hiByte, i1, i2, l1, l2))
							jjstateSet[jjnewStateCnt++] = 134;
						break;
					case 136:
						if (jjCanMove_14(hiByte, i1, i2, l1, l2))
							jjstateSet[jjnewStateCnt++] = 135;
						break;
					default:
						break;
					}
				} while (i != startsAt);
			}
			if (kind != 0x7fffffff) {
				jjmatchedKind = kind;
				jjmatchedPos = curPos;
				kind = 0x7fffffff;
			}
			++curPos;
			if ((i = jjnewStateCnt) == (startsAt = 144 - (jjnewStateCnt = startsAt)))
				return curPos;
			try {
				curChar = input_stream.readChar();
			} catch (java.io.IOException e) {
				return curPos;
			}
		}
	}

	static final int[] jjnextStates = { 138, 140, 141, 143, 115, 117, 75, 79, 67, 71, 60, 63, 53, 55, 82, 84, 86, 88,
			90, 92, 94, 96, 98, 99, 106, 112, 123, 128, 131, 136, };

	private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2) {
		switch (hiByte) {
		case 255:
			return ((jjbitVec0[i2] & l2) != 0L);
		default:
			return false;
		}
	}

	private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2) {
		switch (hiByte) {
		case 126:
			return ((jjbitVec1[i2] & l2) != 0L);
		default:
			return false;
		}
	}

	private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2) {
		switch (hiByte) {
		case 255:
			return ((jjbitVec2[i2] & l2) != 0L);
		default:
			return false;
		}
	}

	private static final boolean jjCanMove_3(int hiByte, int i1, int i2, long l1, long l2) {
		switch (hiByte) {
		case 108:
			return ((jjbitVec3[i2] & l2) != 0L);
		default:
			return false;
		}
	}

	private static final boolean jjCanMove_4(int hiByte, int i1, int i2, long l1, long l2) {
		switch (hiByte) {
		case 131:
			return ((jjbitVec4[i2] & l2) != 0L);
		default:
			return false;
		}
	}

	private static final boolean jjCanMove_5(int hiByte, int i1, int i2, long l1, long l2) {
		switch (hiByte) {
		case 102:
			return ((jjbitVec5[i2] & l2) != 0L);
		default:
			return false;
		}
	}

	private static final boolean jjCanMove_6(int hiByte, int i1, int i2, long l1, long l2) {
		switch (hiByte) {
		case 94:
			return ((jjbitVec6[i2] & l2) != 0L);
		default:
			return false;
		}
	}

	private static final boolean jjCanMove_7(int hiByte, int i1, int i2, long l1, long l2) {
		switch (hiByte) {
		case 135:
			return ((jjbitVec7[i2] & l2) != 0L);
		default:
			return false;
		}
	}

	private static final boolean jjCanMove_8(int hiByte, int i1, int i2, long l1, long l2) {
		switch (hiByte) {
		case 136:
			return ((jjbitVec8[i2] & l2) != 0L);
		default:
			return false;
		}
	}

	private static final boolean jjCanMove_9(int hiByte, int i1, int i2, long l1, long l2) {
		switch (hiByte) {
		case 255:
			return ((jjbitVec9[i2] & l2) != 0L);
		default:
			return false;
		}
	}

	private static final boolean jjCanMove_10(int hiByte, int i1, int i2, long l1, long l2) {
		switch (hiByte) {
		case 131:
			return ((jjbitVec10[i2] & l2) != 0L);
		default:
			return false;
		}
	}

	private static final boolean jjCanMove_11(int hiByte, int i1, int i2, long l1, long l2) {
		switch (hiByte) {
		case 255:
			return ((jjbitVec11[i2] & l2) != 0L);
		default:
			return false;
		}
	}

	private static final boolean jjCanMove_12(int hiByte, int i1, int i2, long l1, long l2) {
		switch (hiByte) {
		case 139:
			return ((jjbitVec12[i2] & l2) != 0L);
		default:
			return false;
		}
	}

	private static final boolean jjCanMove_13(int hiByte, int i1, int i2, long l1, long l2) {
		switch (hiByte) {
		case 255:
			return ((jjbitVec13[i2] & l2) != 0L);
		default:
			return false;
		}
	}

	private static final boolean jjCanMove_14(int hiByte, int i1, int i2, long l1, long l2) {
		switch (hiByte) {
		case 255:
			return ((jjbitVec14[i2] & l2) != 0L);
		default:
			return false;
		}
	}

	private static final boolean jjCanMove_15(int hiByte, int i1, int i2, long l1, long l2) {
		switch (hiByte) {
		case 255:
			return ((jjbitVec15[i2] & l2) != 0L);
		default:
			return false;
		}
	}

	private static final boolean jjCanMove_16(int hiByte, int i1, int i2, long l1, long l2) {
		switch (hiByte) {
		case 255:
			return ((jjbitVec16[i2] & l2) != 0L);
		default:
			return false;
		}
	}

	private static final boolean jjCanMove_17(int hiByte, int i1, int i2, long l1, long l2) {
		switch (hiByte) {
		case 134:
			return ((jjbitVec17[i2] & l2) != 0L);
		default:
			return false;
		}
	}

	private static final boolean jjCanMove_18(int hiByte, int i1, int i2, long l1, long l2) {
		switch (hiByte) {
		case 255:
			return ((jjbitVec18[i2] & l2) != 0L);
		default:
			return false;
		}
	}

	private static final boolean jjCanMove_19(int hiByte, int i1, int i2, long l1, long l2) {
		switch (hiByte) {
		case 126:
			return ((jjbitVec19[i2] & l2) != 0L);
		default:
			return false;
		}
	}

	private static final boolean jjCanMove_20(int hiByte, int i1, int i2, long l1, long l2) {
		switch (hiByte) {
		case 152:
			return ((jjbitVec8[i2] & l2) != 0L);
		default:
			return false;
		}
	}

	private static final boolean jjCanMove_21(int hiByte, int i1, int i2, long l1, long l2) {
		switch (hiByte) {
		case 126:
			return ((jjbitVec20[i2] & l2) != 0L);
		default:
			return false;
		}
	}

	private static final boolean jjCanMove_22(int hiByte, int i1, int i2, long l1, long l2) {
		switch (hiByte) {
		case 255:
			return ((jjbitVec21[i2] & l2) != 0L);
		default:
			return false;
		}
	}

	private static final boolean jjCanMove_23(int hiByte, int i1, int i2, long l1, long l2) {
		switch (hiByte) {
		case 127:
			return ((jjbitVec22[i2] & l2) != 0L);
		default:
			return false;
		}
	}

	private static final boolean jjCanMove_24(int hiByte, int i1, int i2, long l1, long l2) {
		switch (hiByte) {
		case 255:
			return ((jjbitVec23[i2] & l2) != 0L);
		default:
			return false;
		}
	}

	private static final boolean jjCanMove_25(int hiByte, int i1, int i2, long l1, long l2) {
		switch (hiByte) {
		case 141:
			return ((jjbitVec24[i2] & l2) != 0L);
		default:
			return false;
		}
	}

	private static final boolean jjCanMove_26(int hiByte, int i1, int i2, long l1, long l2) {
		switch (hiByte) {
		case 139:
			return ((jjbitVec25[i2] & l2) != 0L);
		default:
			return false;
		}
	}

	private static final boolean jjCanMove_27(int hiByte, int i1, int i2, long l1, long l2) {
		switch (hiByte) {
		case 255:
			return ((jjbitVec26[i2] & l2) != 0L);
		default:
			return false;
		}
	}

	private static final boolean jjCanMove_28(int hiByte, int i1, int i2, long l1, long l2) {
		switch (hiByte) {
		case 134:
			return ((jjbitVec27[i2] & l2) != 0L);
		default:
			return false;
		}
	}

	private static final boolean jjCanMove_29(int hiByte, int i1, int i2, long l1, long l2) {
		switch (hiByte) {
		case 255:
			return ((jjbitVec20[i2] & l2) != 0L);
		default:
			return false;
		}
	}

	private static final boolean jjCanMove_30(int hiByte, int i1, int i2, long l1, long l2) {
		switch (hiByte) {
		case 135:
			return ((jjbitVec28[i2] & l2) != 0L);
		default:
			return false;
		}
	}

	private static final boolean jjCanMove_31(int hiByte, int i1, int i2, long l1, long l2) {
		switch (hiByte) {
		case 78:
			return ((jjbitVec29[i2] & l2) != 0L);
		default:
			return false;
		}
	}

	private static final boolean jjCanMove_32(int hiByte, int i1, int i2, long l1, long l2) {
		switch (hiByte) {
		case 135:
			return ((jjbitVec30[i2] & l2) != 0L);
		default:
			return false;
		}
	}

	private static final boolean jjCanMove_33(int hiByte, int i1, int i2, long l1, long l2) {
		switch (hiByte) {
		case 37:
			return ((jjbitVec31[i2] & l2) != 0L);
		default:
			return false;
		}
	}

	private static final boolean jjCanMove_34(int hiByte, int i1, int i2, long l1, long l2) {
		switch (hiByte) {
		case 78:
			return ((jjbitVec32[i2] & l2) != 0L);
		default:
			return false;
		}
	}

	private static final boolean jjCanMove_35(int hiByte, int i1, int i2, long l1, long l2) {
		switch (hiByte) {
		case 255:
			return ((jjbitVec33[i2] & l2) != 0L);
		default:
			return false;
		}
	}

	private static final boolean jjCanMove_36(int hiByte, int i1, int i2, long l1, long l2) {
		switch (hiByte) {
		case 110:
			return ((jjbitVec34[i2] & l2) != 0L);
		default:
			return false;
		}
	}

	/** Token literal values. */
	public static final String[] jjstrLiteralImages = { "", null, null, null, null, "\12", null, null, null, null, null,
			null, null, null, null, null, null, null, null, null, null, null, "\u7ad5\uff67", "\u7ad5\uff66", null,
			null, null, "\u7ad5\ufffd", null, null, null, };

	/** Lexer state names. */
	public static final String[] lexStateNames = { "DEFAULT", };
	static final long[] jjtoToken = { 0x1fffffe1L, };
	static final long[] jjtoSkip = { 0x1eL, };
	protected SimpleCharStream input_stream;
	private final int[] jjrounds = new int[144];
	private final int[] jjstateSet = new int[288];
	protected char curChar;

	/** Constructor. */
	public ExpressionParserTokenManager(SimpleCharStream stream) {
		if (SimpleCharStream.staticFlag)
			throw new Error("ERROR: Cannot use a static CharStream class with a non-static lexical analyzer.");
		input_stream = stream;
	}

	/** Constructor. */
	public ExpressionParserTokenManager(SimpleCharStream stream, int lexState) {
		this(stream);
		SwitchTo(lexState);
	}

	/** Reinitialise parser. */
	public void ReInit(SimpleCharStream stream) {
		jjmatchedPos = jjnewStateCnt = 0;
		curLexState = defaultLexState;
		input_stream = stream;
		ReInitRounds();
	}

	private void ReInitRounds() {
		int i;
		jjround = 0x80000001;
		for (i = 144; i-- > 0;)
			jjrounds[i] = 0x80000000;
	}

	/** Reinitialise parser. */
	public void ReInit(SimpleCharStream stream, int lexState) {
		ReInit(stream);
		SwitchTo(lexState);
	}

	/** Switch to specified lex state. */
	public void SwitchTo(int lexState) {
		if (lexState >= 1 || lexState < 0)
			throw new TokenMgrError("Error: Ignoring invalid lexical state : " + lexState + ". State unchanged.",
					TokenMgrError.INVALID_LEXICAL_STATE);
		else
			curLexState = lexState;
	}

	protected Token jjFillToken() {
		final Token t;
		final String curTokenImage;
		final int beginLine;
		final int endLine;
		final int beginColumn;
		final int endColumn;
		String im = jjstrLiteralImages[jjmatchedKind];
		curTokenImage = (im == null) ? input_stream.GetImage() : im;
		beginLine = input_stream.getBeginLine();
		beginColumn = input_stream.getBeginColumn();
		endLine = input_stream.getEndLine();
		endColumn = input_stream.getEndColumn();
		t = Token.newToken(jjmatchedKind, curTokenImage);

		t.beginLine = beginLine;
		t.endLine = endLine;
		t.beginColumn = beginColumn;
		t.endColumn = endColumn;

		return t;
	}

	int curLexState = 0;
	int defaultLexState = 0;
	int jjnewStateCnt;
	int jjround;
	int jjmatchedPos;
	int jjmatchedKind;

	/** Get the next Token. */
	public Token getNextToken() {
		Token matchedToken;
		int curPos = 0;

		EOFLoop: for (;;) {
			try {
				curChar = input_stream.BeginToken();
			} catch (java.io.IOException e) {
				jjmatchedKind = 0;
				matchedToken = jjFillToken();
				return matchedToken;
			}

			try {
				input_stream.backup(0);
				while (curChar <= 32 && (0x100002200L & (1L << curChar)) != 0L)
					curChar = input_stream.BeginToken();
			} catch (java.io.IOException e1) {
				continue EOFLoop;
			}
			jjmatchedKind = 0x7fffffff;
			jjmatchedPos = 0;
			curPos = jjMoveStringLiteralDfa0_0();
			if (jjmatchedKind != 0x7fffffff) {
				if (jjmatchedPos + 1 < curPos)
					input_stream.backup(curPos - jjmatchedPos - 1);
				if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L) {
					matchedToken = jjFillToken();
					return matchedToken;
				} else {
					continue EOFLoop;
				}
			}
			int error_line = input_stream.getEndLine();
			int error_column = input_stream.getEndColumn();
			String error_after = null;
			boolean EOFSeen = false;
			try {
				input_stream.readChar();
				input_stream.backup(1);
			} catch (java.io.IOException e1) {
				EOFSeen = true;
				error_after = curPos <= 1 ? "" : input_stream.GetImage();
				if (curChar == '\n' || curChar == '\r') {
					error_line++;
					error_column = 0;
				} else
					error_column++;
			}
			if (!EOFSeen) {
				input_stream.backup(1);
				error_after = curPos <= 1 ? "" : input_stream.GetImage();
			}
			throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar,
					TokenMgrError.LEXICAL_ERROR);
		}
	}

	private void jjCheckNAdd(int state) {
		if (jjrounds[state] != jjround) {
			jjstateSet[jjnewStateCnt++] = state;
			jjrounds[state] = jjround;
		}
	}

	private void jjAddStates(int start, int end) {
		do {
			jjstateSet[jjnewStateCnt++] = jjnextStates[start];
		} while (start++ != end);
	}

	private void jjCheckNAddTwoStates(int state1, int state2) {
		jjCheckNAdd(state1);
		jjCheckNAdd(state2);
	}

}
